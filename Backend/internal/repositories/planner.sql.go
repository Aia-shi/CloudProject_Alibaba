// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: planner.sql

package repository

import (
	"context"
)

const deleteUserExpenses = `-- name: DeleteUserExpenses :exec
DELETE FROM expenses WHERE expenses.id = $1
`

func (q *Queries) DeleteUserExpenses(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUserExpenses, id)
	return err
}

const deleteUserExpensesWithPeriod = `-- name: DeleteUserExpensesWithPeriod :exec
DELETE FROM expenses WHERE expenses.period_id = $1
`

func (q *Queries) DeleteUserExpensesWithPeriod(ctx context.Context, periodID int32) error {
	_, err := q.db.Exec(ctx, deleteUserExpensesWithPeriod, periodID)
	return err
}

const deleteUserIncomes = `-- name: DeleteUserIncomes :exec
DELETE FROM incomes WHERE incomes.id = $1
`

func (q *Queries) DeleteUserIncomes(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUserIncomes, id)
	return err
}

const deleteUserIncomesWithPeriod = `-- name: DeleteUserIncomesWithPeriod :exec
DELETE FROM incomes WHERE incomes.period_id = $1
`

func (q *Queries) DeleteUserIncomesWithPeriod(ctx context.Context, periodID int32) error {
	_, err := q.db.Exec(ctx, deleteUserIncomesWithPeriod, periodID)
	return err
}

const deleteUserPeriods = `-- name: DeleteUserPeriods :exec
DELETE FROM periods WHERE periods.id = $1
`

func (q *Queries) DeleteUserPeriods(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUserPeriods, id)
	return err
}

const getUserExpenses = `-- name: GetUserExpenses :many
SELECT id, period_id, user_id, title, amount, description, date, status, category FROM expenses WHERE expenses.user_id = $1
`

func (q *Queries) GetUserExpenses(ctx context.Context, userID int32) ([]Expense, error) {
	rows, err := q.db.Query(ctx, getUserExpenses, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.PeriodID,
			&i.UserID,
			&i.Title,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Status,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserExpensesById = `-- name: GetUserExpensesById :one
SELECT id, period_id, user_id, title, amount, description, date, status, category FROM expenses WHERE expenses.id = $1
`

func (q *Queries) GetUserExpensesById(ctx context.Context, id int32) (Expense, error) {
	row := q.db.QueryRow(ctx, getUserExpensesById, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.UserID,
		&i.Title,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Status,
		&i.Category,
	)
	return i, err
}

const getUserIncome = `-- name: GetUserIncome :many
SELECT id, period_id, user_id, title, amount, description, date, category FROM incomes WHERE incomes.user_id = $1
`

func (q *Queries) GetUserIncome(ctx context.Context, userID int32) ([]Income, error) {
	rows, err := q.db.Query(ctx, getUserIncome, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Income
	for rows.Next() {
		var i Income
		if err := rows.Scan(
			&i.ID,
			&i.PeriodID,
			&i.UserID,
			&i.Title,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserIncomeById = `-- name: GetUserIncomeById :one
SELECT id, period_id, user_id, title, amount, description, date, category FROM incomes WHERE incomes.id = $1
`

func (q *Queries) GetUserIncomeById(ctx context.Context, id int32) (Income, error) {
	row := q.db.QueryRow(ctx, getUserIncomeById, id)
	var i Income
	err := row.Scan(
		&i.ID,
		&i.PeriodID,
		&i.UserID,
		&i.Title,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.Category,
	)
	return i, err
}

const getUserPeriods = `-- name: GetUserPeriods :many
SELECT id, name, user_id FROM periods WHERE periods.user_id = $1
`

func (q *Queries) GetUserPeriods(ctx context.Context, userID int32) ([]Period, error) {
	rows, err := q.db.Query(ctx, getUserPeriods, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Period
	for rows.Next() {
		var i Period
		if err := rows.Scan(&i.ID, &i.Name, &i.UserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPeriodsById = `-- name: GetUserPeriodsById :one
SELECT id, name, user_id FROM periods WHERE periods.id = $1
`

func (q *Queries) GetUserPeriodsById(ctx context.Context, id int32) (Period, error) {
	row := q.db.QueryRow(ctx, getUserPeriodsById, id)
	var i Period
	err := row.Scan(&i.ID, &i.Name, &i.UserID)
	return i, err
}

const insertUserExpenses = `-- name: InsertUserExpenses :exec
INSERT INTO expenses (period_id, user_id, title, amount, description, date, status, category) VALUES (
    $1,
    $2,  
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
  )
`

type InsertUserExpensesParams struct {
	PeriodID    int32   `json:"period_id"`
	UserID      int32   `json:"user_id"`
	Title       string  `json:"title"`
	Amount      float64 `json:"amount"`
	Description string  `json:"description"`
	Date        string  `json:"date"`
	Status      string  `json:"status"`
	Category    string  `json:"category"`
}

func (q *Queries) InsertUserExpenses(ctx context.Context, arg InsertUserExpensesParams) error {
	_, err := q.db.Exec(ctx, insertUserExpenses,
		arg.PeriodID,
		arg.UserID,
		arg.Title,
		arg.Amount,
		arg.Description,
		arg.Date,
		arg.Status,
		arg.Category,
	)
	return err
}

const insertUserIncomes = `-- name: InsertUserIncomes :exec
INSERT INTO incomes (period_id, user_id, title, amount, description, date, category) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
  )
`

type InsertUserIncomesParams struct {
	PeriodID    int32   `json:"period_id"`
	UserID      int32   `json:"user_id"`
	Title       string  `json:"title"`
	Amount      float64 `json:"amount"`
	Description string  `json:"description"`
	Date        string  `json:"date"`
	Category    string  `json:"category"`
}

func (q *Queries) InsertUserIncomes(ctx context.Context, arg InsertUserIncomesParams) error {
	_, err := q.db.Exec(ctx, insertUserIncomes,
		arg.PeriodID,
		arg.UserID,
		arg.Title,
		arg.Amount,
		arg.Description,
		arg.Date,
		arg.Category,
	)
	return err
}

const insertUserPeriods = `-- name: InsertUserPeriods :exec
INSERT INTO periods (user_id, name) VALUES (
    $1,
    $2
  )
`

type InsertUserPeriodsParams struct {
	UserID int32  `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) InsertUserPeriods(ctx context.Context, arg InsertUserPeriodsParams) error {
	_, err := q.db.Exec(ctx, insertUserPeriods, arg.UserID, arg.Name)
	return err
}

const updateUserExpenses = `-- name: UpdateUserExpenses :exec
UPDATE expenses SET
  title = $1::text,
  amount = $2::float,
  description = $3::text,
  date = $4::text,
  status = $5::text,
  category = $6::text
WHERE expenses.id = $7::int
`

type UpdateUserExpensesParams struct {
	NewTitle       string  `json:"new_title"`
	NewAmount      float64 `json:"new_amount"`
	NewDescription string  `json:"new_description"`
	NewDate        string  `json:"new_date"`
	NewStatus      string  `json:"new_status"`
	NewCategory    string  `json:"new_category"`
	ID             int32   `json:"id"`
}

func (q *Queries) UpdateUserExpenses(ctx context.Context, arg UpdateUserExpensesParams) error {
	_, err := q.db.Exec(ctx, updateUserExpenses,
		arg.NewTitle,
		arg.NewAmount,
		arg.NewDescription,
		arg.NewDate,
		arg.NewStatus,
		arg.NewCategory,
		arg.ID,
	)
	return err
}

const updateUserIncomes = `-- name: UpdateUserIncomes :exec
UPDATE incomes SET
  title = $1::text,
  amount = $2::float,
  description = $3::text,
  date = $4::text,
  category = $5::text
WHERE incomes.id = $6::int
`

type UpdateUserIncomesParams struct {
	NewTitle       string  `json:"new_title"`
	NewAmount      float64 `json:"new_amount"`
	NewDescription string  `json:"new_description"`
	NewDate        string  `json:"new_date"`
	NewCategory    string  `json:"new_category"`
	ID             int32   `json:"id"`
}

func (q *Queries) UpdateUserIncomes(ctx context.Context, arg UpdateUserIncomesParams) error {
	_, err := q.db.Exec(ctx, updateUserIncomes,
		arg.NewTitle,
		arg.NewAmount,
		arg.NewDescription,
		arg.NewDate,
		arg.NewCategory,
		arg.ID,
	)
	return err
}

const updateUserPeriods = `-- name: UpdateUserPeriods :exec
UPDATE periods SET
  name = $1::text
WHERE periods.id = $2::int
`

type UpdateUserPeriodsParams struct {
	NewName string `json:"new_name"`
	ID      int32  `json:"id"`
}

func (q *Queries) UpdateUserPeriods(ctx context.Context, arg UpdateUserPeriodsParams) error {
	_, err := q.db.Exec(ctx, updateUserPeriods, arg.NewName, arg.ID)
	return err
}
